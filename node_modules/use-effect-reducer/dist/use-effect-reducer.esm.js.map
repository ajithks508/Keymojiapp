{"version":3,"file":"use-effect-reducer.esm.js","sources":["../src/index.tsx"],"sourcesContent":["import { useReducer, useEffect, useCallback, useRef, useMemo } from 'react';\n\ntype CleanupFunction = () => void;\n\nexport type EffectFunction<\n  TState,\n  TEvent extends EventObject,\n  TEffect extends EffectObject<TState, TEvent>\n> = (\n  state: TState,\n  effect: TEffect,\n  dispatch: React.Dispatch<TEvent>\n) => CleanupFunction | void;\n\nexport interface EffectObject<TState, TEvent extends EventObject> {\n  [key: string]: any;\n  type: string;\n  exec?: EffectFunction<TState, TEvent, any>;\n}\n\nexport type Effect<\n  TState,\n  TEvent extends EventObject,\n  TEffect extends EffectObject<TState, TEvent>\n> = TEffect | EffectFunction<TState, TEvent, TEffect>;\n\ntype EntityTuple<TState, TEvent extends EventObject> = [\n  TState,\n  EffectEntity<TState, TEvent>[]\n];\n\ntype AggregatedEffectsState<TState, TEvent extends EventObject> = [\n  TState,\n  EntityTuple<TState, TEvent>[],\n  EffectEntity<TState, TEvent>[]\n];\n\nexport interface EventObject {\n  type: string;\n  [key: string]: any;\n}\n\nenum EntityStatus {\n  Idle,\n  Started,\n  Stopped,\n}\n\nexport interface EffectEntity<TState, TEvent extends EventObject> {\n  type: string;\n  status: EntityStatus;\n  start: (state: TState, dispatch: React.Dispatch<TEvent>) => void;\n  stop: () => void;\n}\n\nfunction createEffectEntity<\n  TState,\n  TEvent extends EventObject,\n  TEffect extends EffectObject<TState, TEvent>\n>(effect: TEffect): EffectEntity<TState, TEvent> {\n  let effectCleanup: CleanupFunction | void;\n\n  const entity: EffectEntity<TState, TEvent> = {\n    type: effect.type,\n    status: EntityStatus.Idle,\n    start: (state, dispatch) => {\n      if (effect.exec) {\n        effectCleanup = effect.exec(state, effect, dispatch);\n      }\n      entity.status = EntityStatus.Started;\n    },\n    stop: () => {\n      if (effectCleanup && typeof effectCleanup === 'function') {\n        effectCleanup();\n      }\n      entity.status = EntityStatus.Stopped;\n    },\n  };\n\n  return entity;\n}\n\nexport interface EffectReducerExec<\n  TState,\n  TEvent extends EventObject,\n  TEffect extends EffectObject<TState, TEvent>\n> {\n  (effect: TEffect | EffectFunction<TState, TEvent, TEffect>): EffectEntity<\n    TState,\n    TEvent\n  >;\n  stop: (entity: EffectEntity<TState, TEvent>) => void;\n  replace: (\n    entity: EffectEntity<TState, TEvent> | undefined,\n    effect: TEffect | EffectFunction<TState, TEvent, TEffect>\n  ) => EffectEntity<TState, TEvent>;\n}\n\nexport type EffectReducer<\n  TState,\n  TEvent extends EventObject,\n  TEffect extends EffectObject<TState, TEvent> = EffectObject<TState, TEvent>\n> = (\n  state: TState,\n  event: TEvent,\n  exec: EffectReducerExec<TState, TEvent, TEffect>\n) => TState;\n\nconst flushEffectsSymbol = Symbol();\n\n// ðŸš½\ninterface FlushEvent {\n  type: typeof flushEffectsSymbol;\n  count: number;\n}\n\nexport function toEffect<TState, TEvent extends EventObject>(\n  exec: EffectFunction<TState, TEvent, any>\n): Effect<TState, TEvent, any> {\n  return {\n    type: exec.name,\n    exec,\n  };\n}\n\nexport type EffectsMap<\n  TState,\n  TEvent extends EventObject,\n  TEffect extends EffectObject<TState, TEvent>\n> = {\n  [key in TEffect['type']]: EffectFunction<\n    TState,\n    TEvent,\n    TEffect & { type: key }\n  >;\n};\n\nconst toEventObject = <TEvent extends EventObject>(\n  event: TEvent['type'] | TEvent\n): TEvent => {\n  if (typeof event === 'string') {\n    return { type: event } as TEvent;\n  }\n\n  return event;\n};\n\nconst toEffectObject = <\n  TState,\n  TEvent extends EventObject,\n  TEffect extends EffectObject<TState, TEvent>\n>(\n  effect: TEffect | EffectFunction<TState, TEvent, TEffect>,\n  effectsMap?: EffectsMap<TState, TEvent, TEffect>\n): TEffect => {\n  const type = typeof effect === 'function' ? effect.name : effect.type;\n  const customExec = effectsMap\n    ? effectsMap[type as TEffect['type']]\n    : undefined;\n  const exec =\n    customExec || (typeof effect === 'function' ? effect : effect.exec);\n  const other = typeof effect === 'function' ? {} : effect;\n\n  return { ...other, type, exec } as TEffect;\n};\n\nexport type InitialEffectStateGetter<\n  TState,\n  TEvent extends EventObject,\n  TEffect extends EffectObject<TState, any>\n> = (\n  exec: (\n    effect: TEffect | EffectFunction<TState, any, TEffect>\n  ) => EffectEntity<TState, TEvent>\n) => TState;\n\nexport function useEffectReducer<\n  TState,\n  TEvent extends EventObject,\n  TEffect extends EffectObject<TState, TEvent> = EffectObject<TState, TEvent>\n>(\n  effectReducer: EffectReducer<TState, TEvent, TEffect>,\n  initialState: TState | InitialEffectStateGetter<TState, TEvent, TEffect>,\n  effectsMap?: EffectsMap<TState, TEvent, TEffect>\n): [TState, React.Dispatch<TEvent | TEvent['type']>] {\n  const entitiesRef = useRef<Set<EffectEntity<TState, TEvent>>>(new Set());\n  const wrappedReducer = (\n    [state, stateEffectTuples, entitiesToStop]: AggregatedEffectsState<\n      TState,\n      TEvent\n    >,\n    event: TEvent | FlushEvent\n  ): AggregatedEffectsState<TState, TEvent> => {\n    const nextEffectEntities: Array<EffectEntity<TState, TEvent>> = [];\n    const nextEntitiesToStop: Array<EffectEntity<TState, TEvent>> = [];\n\n    if (event.type === flushEffectsSymbol) {\n      // Record that effects have already been executed\n      return [state, stateEffectTuples.slice(event.count), nextEntitiesToStop];\n    }\n\n    const exec = (\n      effect: TEffect | EffectFunction<TState, TEvent, TEffect>\n    ) => {\n      const effectObject = toEffectObject(effect, effectsMap);\n      const effectEntity = createEffectEntity<TState, TEvent, TEffect>(\n        effectObject\n      );\n      nextEffectEntities.push(effectEntity);\n\n      return effectEntity;\n    };\n\n    exec.stop = (entity: EffectEntity<TState, TEvent>) => {\n      nextEntitiesToStop.push(entity);\n    };\n\n    exec.replace = (\n      entity: EffectEntity<TState, TEvent>,\n      effect: TEffect | EffectFunction<TState, TEvent, TEffect>\n    ) => {\n      if (entity) {\n        nextEntitiesToStop.push(entity);\n      }\n      return exec(effect);\n    };\n\n    const nextState = effectReducer(\n      state,\n      event,\n      exec as EffectReducerExec<TState, TEvent, TEffect>\n    );\n\n    return [\n      nextState,\n      nextEffectEntities.length\n        ? [...stateEffectTuples, [nextState, nextEffectEntities]]\n        : stateEffectTuples,\n      entitiesToStop.length\n        ? [...entitiesToStop, ...nextEntitiesToStop]\n        : nextEntitiesToStop,\n    ];\n  };\n\n  const initialStateAndEffects: AggregatedEffectsState<\n    TState,\n    TEvent\n  > = useMemo(() => {\n    if (typeof initialState === 'function') {\n      const initialEffectEntities: Array<EffectEntity<TState, TEvent>> = [];\n\n      const resolvedInitialState = (initialState as InitialEffectStateGetter<\n        TState,\n        TEvent,\n        TEffect\n      >)(effect => {\n        const effectObject = toEffectObject(effect, effectsMap);\n        const effectEntity = createEffectEntity<TState, TEvent, TEffect>(\n          effectObject\n        );\n\n        initialEffectEntities.push(effectEntity);\n        return effectEntity;\n      });\n\n      return [\n        resolvedInitialState,\n        [[resolvedInitialState, initialEffectEntities]],\n        [],\n      ];\n    }\n\n    return [initialState, [], []];\n  }, []);\n\n  const [\n    [state, effectStateEntityTuples, entitiesToStop],\n    dispatch,\n  ] = useReducer(wrappedReducer, initialStateAndEffects);\n\n  const wrappedDispatch = useCallback((event: TEvent | TEvent['type']) => {\n    dispatch(toEventObject(event));\n  }, []);\n\n  // First, stop all effects marked for disposal\n  useEffect(() => {\n    if (entitiesToStop.length) {\n      entitiesToStop.forEach(entity => {\n        entity.stop();\n        entitiesRef.current.delete(entity);\n      });\n    }\n  }, [entitiesToStop]);\n\n  // Then, execute all effects queued for execution\n  useEffect(() => {\n    if (effectStateEntityTuples.length) {\n      effectStateEntityTuples.forEach(([effectState, effectEntities]) => {\n        effectEntities.forEach(entity => {\n          if (entity.status !== EntityStatus.Idle) return;\n\n          entitiesRef.current.add(entity);\n          entity.start(effectState, dispatch);\n        });\n      });\n\n      // Optimization: flush effects that have been executed\n      // so that they no longer needed to be iterated through\n      dispatch({\n        type: flushEffectsSymbol,\n        count: effectStateEntityTuples.length,\n      });\n    }\n  }, [effectStateEntityTuples]);\n\n  // When the component unmounts, stop all effects that are\n  // currently started\n  useEffect(() => {\n    return () => {\n      entitiesRef.current.forEach(entity => {\n        if (entity.status === EntityStatus.Started) {\n          entity.stop();\n        }\n      });\n    };\n  }, []);\n\n  return [state, wrappedDispatch];\n}\n"],"names":["EntityStatus","createEffectEntity","effect","effectCleanup","entity","type","status","Idle","start","state","dispatch","exec","Started","stop","Stopped","flushEffectsSymbol","Symbol","toEffect","name","toEventObject","event","toEffectObject","effectsMap","customExec","undefined","other","useEffectReducer","effectReducer","initialState","entitiesRef","useRef","Set","wrappedReducer","stateEffectTuples","entitiesToStop","nextEffectEntities","nextEntitiesToStop","slice","count","effectObject","effectEntity","push","replace","nextState","length","initialStateAndEffects","useMemo","initialEffectEntities","resolvedInitialState","useReducer","effectStateEntityTuples","wrappedDispatch","useCallback","useEffect","forEach","current","effectState","effectEntities","add"],"mappings":"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"}