{"version":3,"file":"use-effect-reducer.cjs.production.min.js","sources":["../src/index.tsx"],"sourcesContent":["import { useReducer, useEffect, useCallback, useRef, useMemo } from 'react';\n\ntype CleanupFunction = () => void;\n\nexport type EffectFunction<\n  TState,\n  TEvent extends EventObject,\n  TEffect extends EffectObject<TState, TEvent>\n> = (\n  state: TState,\n  effect: TEffect,\n  dispatch: React.Dispatch<TEvent>\n) => CleanupFunction | void;\n\nexport interface EffectObject<TState, TEvent extends EventObject> {\n  [key: string]: any;\n  type: string;\n  exec?: EffectFunction<TState, TEvent, any>;\n}\n\nexport type Effect<\n  TState,\n  TEvent extends EventObject,\n  TEffect extends EffectObject<TState, TEvent>\n> = TEffect | EffectFunction<TState, TEvent, TEffect>;\n\ntype EntityTuple<TState, TEvent extends EventObject> = [\n  TState,\n  EffectEntity<TState, TEvent>[]\n];\n\ntype AggregatedEffectsState<TState, TEvent extends EventObject> = [\n  TState,\n  EntityTuple<TState, TEvent>[],\n  EffectEntity<TState, TEvent>[]\n];\n\nexport interface EventObject {\n  type: string;\n  [key: string]: any;\n}\n\nenum EntityStatus {\n  Idle,\n  Started,\n  Stopped,\n}\n\nexport interface EffectEntity<TState, TEvent extends EventObject> {\n  type: string;\n  status: EntityStatus;\n  start: (state: TState, dispatch: React.Dispatch<TEvent>) => void;\n  stop: () => void;\n}\n\nfunction createEffectEntity<\n  TState,\n  TEvent extends EventObject,\n  TEffect extends EffectObject<TState, TEvent>\n>(effect: TEffect): EffectEntity<TState, TEvent> {\n  let effectCleanup: CleanupFunction | void;\n\n  const entity: EffectEntity<TState, TEvent> = {\n    type: effect.type,\n    status: EntityStatus.Idle,\n    start: (state, dispatch) => {\n      if (effect.exec) {\n        effectCleanup = effect.exec(state, effect, dispatch);\n      }\n      entity.status = EntityStatus.Started;\n    },\n    stop: () => {\n      if (effectCleanup && typeof effectCleanup === 'function') {\n        effectCleanup();\n      }\n      entity.status = EntityStatus.Stopped;\n    },\n  };\n\n  return entity;\n}\n\nexport interface EffectReducerExec<\n  TState,\n  TEvent extends EventObject,\n  TEffect extends EffectObject<TState, TEvent>\n> {\n  (effect: TEffect | EffectFunction<TState, TEvent, TEffect>): EffectEntity<\n    TState,\n    TEvent\n  >;\n  stop: (entity: EffectEntity<TState, TEvent>) => void;\n  replace: (\n    entity: EffectEntity<TState, TEvent> | undefined,\n    effect: TEffect | EffectFunction<TState, TEvent, TEffect>\n  ) => EffectEntity<TState, TEvent>;\n}\n\nexport type EffectReducer<\n  TState,\n  TEvent extends EventObject,\n  TEffect extends EffectObject<TState, TEvent> = EffectObject<TState, TEvent>\n> = (\n  state: TState,\n  event: TEvent,\n  exec: EffectReducerExec<TState, TEvent, TEffect>\n) => TState;\n\nconst flushEffectsSymbol = Symbol();\n\n// ðŸš½\ninterface FlushEvent {\n  type: typeof flushEffectsSymbol;\n  count: number;\n}\n\nexport function toEffect<TState, TEvent extends EventObject>(\n  exec: EffectFunction<TState, TEvent, any>\n): Effect<TState, TEvent, any> {\n  return {\n    type: exec.name,\n    exec,\n  };\n}\n\nexport type EffectsMap<\n  TState,\n  TEvent extends EventObject,\n  TEffect extends EffectObject<TState, TEvent>\n> = {\n  [key in TEffect['type']]: EffectFunction<\n    TState,\n    TEvent,\n    TEffect & { type: key }\n  >;\n};\n\nconst toEventObject = <TEvent extends EventObject>(\n  event: TEvent['type'] | TEvent\n): TEvent => {\n  if (typeof event === 'string') {\n    return { type: event } as TEvent;\n  }\n\n  return event;\n};\n\nconst toEffectObject = <\n  TState,\n  TEvent extends EventObject,\n  TEffect extends EffectObject<TState, TEvent>\n>(\n  effect: TEffect | EffectFunction<TState, TEvent, TEffect>,\n  effectsMap?: EffectsMap<TState, TEvent, TEffect>\n): TEffect => {\n  const type = typeof effect === 'function' ? effect.name : effect.type;\n  const customExec = effectsMap\n    ? effectsMap[type as TEffect['type']]\n    : undefined;\n  const exec =\n    customExec || (typeof effect === 'function' ? effect : effect.exec);\n  const other = typeof effect === 'function' ? {} : effect;\n\n  return { ...other, type, exec } as TEffect;\n};\n\nexport type InitialEffectStateGetter<\n  TState,\n  TEvent extends EventObject,\n  TEffect extends EffectObject<TState, any>\n> = (\n  exec: (\n    effect: TEffect | EffectFunction<TState, any, TEffect>\n  ) => EffectEntity<TState, TEvent>\n) => TState;\n\nexport function useEffectReducer<\n  TState,\n  TEvent extends EventObject,\n  TEffect extends EffectObject<TState, TEvent> = EffectObject<TState, TEvent>\n>(\n  effectReducer: EffectReducer<TState, TEvent, TEffect>,\n  initialState: TState | InitialEffectStateGetter<TState, TEvent, TEffect>,\n  effectsMap?: EffectsMap<TState, TEvent, TEffect>\n): [TState, React.Dispatch<TEvent | TEvent['type']>] {\n  const entitiesRef = useRef<Set<EffectEntity<TState, TEvent>>>(new Set());\n  const wrappedReducer = (\n    [state, stateEffectTuples, entitiesToStop]: AggregatedEffectsState<\n      TState,\n      TEvent\n    >,\n    event: TEvent | FlushEvent\n  ): AggregatedEffectsState<TState, TEvent> => {\n    const nextEffectEntities: Array<EffectEntity<TState, TEvent>> = [];\n    const nextEntitiesToStop: Array<EffectEntity<TState, TEvent>> = [];\n\n    if (event.type === flushEffectsSymbol) {\n      // Record that effects have already been executed\n      return [state, stateEffectTuples.slice(event.count), nextEntitiesToStop];\n    }\n\n    const exec = (\n      effect: TEffect | EffectFunction<TState, TEvent, TEffect>\n    ) => {\n      const effectObject = toEffectObject(effect, effectsMap);\n      const effectEntity = createEffectEntity<TState, TEvent, TEffect>(\n        effectObject\n      );\n      nextEffectEntities.push(effectEntity);\n\n      return effectEntity;\n    };\n\n    exec.stop = (entity: EffectEntity<TState, TEvent>) => {\n      nextEntitiesToStop.push(entity);\n    };\n\n    exec.replace = (\n      entity: EffectEntity<TState, TEvent>,\n      effect: TEffect | EffectFunction<TState, TEvent, TEffect>\n    ) => {\n      if (entity) {\n        nextEntitiesToStop.push(entity);\n      }\n      return exec(effect);\n    };\n\n    const nextState = effectReducer(\n      state,\n      event,\n      exec as EffectReducerExec<TState, TEvent, TEffect>\n    );\n\n    return [\n      nextState,\n      nextEffectEntities.length\n        ? [...stateEffectTuples, [nextState, nextEffectEntities]]\n        : stateEffectTuples,\n      entitiesToStop.length\n        ? [...entitiesToStop, ...nextEntitiesToStop]\n        : nextEntitiesToStop,\n    ];\n  };\n\n  const initialStateAndEffects: AggregatedEffectsState<\n    TState,\n    TEvent\n  > = useMemo(() => {\n    if (typeof initialState === 'function') {\n      const initialEffectEntities: Array<EffectEntity<TState, TEvent>> = [];\n\n      const resolvedInitialState = (initialState as InitialEffectStateGetter<\n        TState,\n        TEvent,\n        TEffect\n      >)(effect => {\n        const effectObject = toEffectObject(effect, effectsMap);\n        const effectEntity = createEffectEntity<TState, TEvent, TEffect>(\n          effectObject\n        );\n\n        initialEffectEntities.push(effectEntity);\n        return effectEntity;\n      });\n\n      return [\n        resolvedInitialState,\n        [[resolvedInitialState, initialEffectEntities]],\n        [],\n      ];\n    }\n\n    return [initialState, [], []];\n  }, []);\n\n  const [\n    [state, effectStateEntityTuples, entitiesToStop],\n    dispatch,\n  ] = useReducer(wrappedReducer, initialStateAndEffects);\n\n  const wrappedDispatch = useCallback((event: TEvent | TEvent['type']) => {\n    dispatch(toEventObject(event));\n  }, []);\n\n  // First, stop all effects marked for disposal\n  useEffect(() => {\n    if (entitiesToStop.length) {\n      entitiesToStop.forEach(entity => {\n        entity.stop();\n        entitiesRef.current.delete(entity);\n      });\n    }\n  }, [entitiesToStop]);\n\n  // Then, execute all effects queued for execution\n  useEffect(() => {\n    if (effectStateEntityTuples.length) {\n      effectStateEntityTuples.forEach(([effectState, effectEntities]) => {\n        effectEntities.forEach(entity => {\n          if (entity.status !== EntityStatus.Idle) return;\n\n          entitiesRef.current.add(entity);\n          entity.start(effectState, dispatch);\n        });\n      });\n\n      // Optimization: flush effects that have been executed\n      // so that they no longer needed to be iterated through\n      dispatch({\n        type: flushEffectsSymbol,\n        count: effectStateEntityTuples.length,\n      });\n    }\n  }, [effectStateEntityTuples]);\n\n  // When the component unmounts, stop all effects that are\n  // currently started\n  useEffect(() => {\n    return () => {\n      entitiesRef.current.forEach(entity => {\n        if (entity.status === EntityStatus.Started) {\n          entity.stop();\n        }\n      });\n    };\n  }, []);\n\n  return [state, wrappedDispatch];\n}\n"],"names":["EntityStatus","createEffectEntity","effect","effectCleanup","entity","type","status","Idle","start","state","dispatch","exec","Started","stop","Stopped","flushEffectsSymbol","Symbol","toEffectObject","effectsMap","name","undefined","effectReducer","initialState","entitiesRef","useRef","Set","initialStateAndEffects","useMemo","initialEffectEntities","resolvedInitialState","effectEntity","push","useReducer","event","stateEffectTuples","entitiesToStop","nextEffectEntities","nextEntitiesToStop","slice","count","replace","nextState","length","effectStateEntityTuples","wrappedDispatch","useCallback","toEventObject","useEffect","forEach","current","effectState","add"],"mappings":"wEA0CKA,oOAaL,SAASC,EAIPC,OACIC,EAEEC,EAAuC,CAC3CC,KAAMH,EAAOG,KACbC,OAAQN,EAAaO,KACrBC,MAAO,SAACC,EAAOC,GACTR,EAAOS,OACTR,EAAgBD,EAAOS,KAAKF,EAAOP,EAAQQ,IAE7CN,EAAOE,OAASN,EAAaY,SAE/BC,KAAM,WACAV,GAA0C,mBAAlBA,GAC1BA,IAEFC,EAAOE,OAASN,EAAac,iBAI1BV,GArCT,SAAKJ,GACHA,mBACAA,yBACAA,yBAHF,CAAKA,IAAAA,OAkEL,IAAMe,EAAqBC,SAuCrBC,EAAiB,SAKrBf,EACAgB,OAEMb,EAAyB,mBAAXH,EAAwBA,EAAOiB,KAAOjB,EAAOG,iBAMjC,mBAAXH,EAAwB,GAAKA,GAE/BG,KAAAA,EAAMM,MAPNO,EACfA,EAAWb,QACXe,KAE+B,mBAAXlB,EAAwBA,EAASA,EAAOS,mCA3ChEA,SAEO,CACLN,KAAMM,EAAKQ,KACXR,KAAAA,sCA4DFU,EACAC,EACAJ,OAEMK,EAAcC,SAA0C,IAAIC,KA2D5DC,EAGFC,WAAQ,cACkB,mBAAjBL,EAA6B,KAChCM,EAA6D,GAE7DC,EAAwBP,GAI3B,SAAApB,OAEK4B,EAAe7B,EADAgB,EAAef,EAAQgB,WAK5CU,EAAsBG,KAAKD,GACpBA,WAGF,CACLD,EACA,CAAC,CAACA,EAAsBD,IACxB,UAIG,CAACN,EAAc,GAAI,MACzB,MAKCU,cA5FmB,WAKrBC,OAJCxB,OAAOyB,OAAmBC,OAMrBC,EAA0D,GAC1DC,EAA0D,MAE5DJ,EAAM5B,OAASU,QAEV,CAACN,EAAOyB,EAAkBI,MAAML,EAAMM,OAAQF,OAGjD1B,EAAO,SACXT,OAGM4B,EAAe7B,EADAgB,EAAef,EAAQgB,WAI5CkB,EAAmBL,KAAKD,GAEjBA,GAGTnB,EAAKE,KAAO,SAACT,GACXiC,EAAmBN,KAAK3B,IAG1BO,EAAK6B,QAAU,SACbpC,EACAF,UAEIE,GACFiC,EAAmBN,KAAK3B,GAEnBO,EAAKT,QAGRuC,EAAYpB,EAChBZ,EACAwB,EACAtB,SAGK,CACL8B,EACAL,EAAmBM,iBACXR,GAAmB,CAACO,EAAWL,KACnCF,EACJC,EAAeO,iBACPP,EAAmBE,GACvBA,KAsCuBX,UAF5BjB,OAAOkC,OAAyBR,OACjCzB,OAGIkC,EAAkBC,eAAY,SAACZ,GACnCvB,EAhJkB,SACpBuB,SAEqB,iBAAVA,EACF,CAAE5B,KAAM4B,GAGVA,EAyIIa,CAAcb,MACtB,WAGHc,aAAU,WACJZ,EAAeO,QACjBP,EAAea,SAAQ,SAAA5C,GACrBA,EAAOS,OACPU,EAAY0B,eAAe7C,QAG9B,CAAC+B,IAGJY,aAAU,WACJJ,EAAwBD,SAC1BC,EAAwBK,SAAQ,gBAAEE,YACjBF,SAAQ,SAAA5C,GACjBA,EAAOE,SAAWN,EAAaO,OAEnCgB,EAAY0B,QAAQE,IAAI/C,GACxBA,EAAOI,MAAM0C,EAAaxC,UAM9BA,EAAS,CACPL,KAAMU,EACNwB,MAAOI,EAAwBD,YAGlC,CAACC,IAIJI,aAAU,kBACD,WACLxB,EAAY0B,QAAQD,SAAQ,SAAA5C,GACtBA,EAAOE,SAAWN,EAAaY,SACjCR,EAAOS,aAIZ,IAEI,CAACJ,EAAOmC"}