'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var react = require('react');

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

var EntityStatus;

(function (EntityStatus) {
  EntityStatus[EntityStatus["Idle"] = 0] = "Idle";
  EntityStatus[EntityStatus["Started"] = 1] = "Started";
  EntityStatus[EntityStatus["Stopped"] = 2] = "Stopped";
})(EntityStatus || (EntityStatus = {}));

function createEffectEntity(effect) {
  var effectCleanup;
  var entity = {
    type: effect.type,
    status: EntityStatus.Idle,
    start: function start(state, dispatch) {
      if (effect.exec) {
        effectCleanup = effect.exec(state, effect, dispatch);
      }

      entity.status = EntityStatus.Started;
    },
    stop: function stop() {
      if (effectCleanup && typeof effectCleanup === 'function') {
        effectCleanup();
      }

      entity.status = EntityStatus.Stopped;
    }
  };
  return entity;
}

var flushEffectsSymbol = /*#__PURE__*/Symbol();
function toEffect(exec) {
  return {
    type: exec.name,
    exec: exec
  };
}

var toEventObject = function toEventObject(event) {
  if (typeof event === 'string') {
    return {
      type: event
    };
  }

  return event;
};

var toEffectObject = function toEffectObject(effect, effectsMap) {
  var type = typeof effect === 'function' ? effect.name : effect.type;
  var customExec = effectsMap ? effectsMap[type] : undefined;
  var exec = customExec || (typeof effect === 'function' ? effect : effect.exec);
  var other = typeof effect === 'function' ? {} : effect;
  return _extends({}, other, {
    type: type,
    exec: exec
  });
};

function useEffectReducer(effectReducer, initialState, effectsMap) {
  var entitiesRef = react.useRef(new Set());

  var wrappedReducer = function wrappedReducer(_ref, event) {
    var state = _ref[0],
        stateEffectTuples = _ref[1],
        entitiesToStop = _ref[2];
    var nextEffectEntities = [];
    var nextEntitiesToStop = [];

    if (event.type === flushEffectsSymbol) {
      // Record that effects have already been executed
      return [state, stateEffectTuples.slice(event.count), nextEntitiesToStop];
    }

    var exec = function exec(effect) {
      var effectObject = toEffectObject(effect, effectsMap);
      var effectEntity = createEffectEntity(effectObject);
      nextEffectEntities.push(effectEntity);
      return effectEntity;
    };

    exec.stop = function (entity) {
      nextEntitiesToStop.push(entity);
    };

    exec.replace = function (entity, effect) {
      if (entity) {
        nextEntitiesToStop.push(entity);
      }

      return exec(effect);
    };

    var nextState = effectReducer(state, event, exec);
    return [nextState, nextEffectEntities.length ? [].concat(stateEffectTuples, [[nextState, nextEffectEntities]]) : stateEffectTuples, entitiesToStop.length ? [].concat(entitiesToStop, nextEntitiesToStop) : nextEntitiesToStop];
  };

  var initialStateAndEffects = react.useMemo(function () {
    if (typeof initialState === 'function') {
      var initialEffectEntities = [];
      var resolvedInitialState = initialState(function (effect) {
        var effectObject = toEffectObject(effect, effectsMap);
        var effectEntity = createEffectEntity(effectObject);
        initialEffectEntities.push(effectEntity);
        return effectEntity;
      });
      return [resolvedInitialState, [[resolvedInitialState, initialEffectEntities]], []];
    }

    return [initialState, [], []];
  }, []);

  var _useReducer = react.useReducer(wrappedReducer, initialStateAndEffects),
      _useReducer$ = _useReducer[0],
      state = _useReducer$[0],
      effectStateEntityTuples = _useReducer$[1],
      entitiesToStop = _useReducer$[2],
      dispatch = _useReducer[1];

  var wrappedDispatch = react.useCallback(function (event) {
    dispatch(toEventObject(event));
  }, []); // First, stop all effects marked for disposal

  react.useEffect(function () {
    if (entitiesToStop.length) {
      entitiesToStop.forEach(function (entity) {
        entity.stop();
        entitiesRef.current["delete"](entity);
      });
    }
  }, [entitiesToStop]); // Then, execute all effects queued for execution

  react.useEffect(function () {
    if (effectStateEntityTuples.length) {
      effectStateEntityTuples.forEach(function (_ref2) {
        var effectState = _ref2[0],
            effectEntities = _ref2[1];
        effectEntities.forEach(function (entity) {
          if (entity.status !== EntityStatus.Idle) return;
          entitiesRef.current.add(entity);
          entity.start(effectState, dispatch);
        });
      }); // Optimization: flush effects that have been executed
      // so that they no longer needed to be iterated through

      dispatch({
        type: flushEffectsSymbol,
        count: effectStateEntityTuples.length
      });
    }
  }, [effectStateEntityTuples]); // When the component unmounts, stop all effects that are
  // currently started

  react.useEffect(function () {
    return function () {
      entitiesRef.current.forEach(function (entity) {
        if (entity.status === EntityStatus.Started) {
          entity.stop();
        }
      });
    };
  }, []);
  return [state, wrappedDispatch];
}

exports.toEffect = toEffect;
exports.useEffectReducer = useEffectReducer;
//# sourceMappingURL=use-effect-reducer.cjs.development.js.map
